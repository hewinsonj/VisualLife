(All Three.js logic is now inside the script block below)
<!DOCTYPE html>
<html lang="en">
  <head>
    <base href="." />
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>VisualLife</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        position: fixed;
        top: 0;
        left: 0;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: none;
        touch-action: none;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      button {
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
        touch-action: manipulation;
      }
      body.mobile #hud-buttons button {
        /* padding: 6px 10px !important; */
        /* font-size: 12px !important; */
        border-radius: 4px !important;
        opacity: 0.9;
      }
      body:not(.mobile) #hud-buttons button {
        padding: 6px 10px !important;
        font-size: 12px !important;
        border-radius: 4px !important;
      }
      .hidden {
        display: none;
      }

      #seizureWarning {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.96);
        color: white;
        font-family: monospace;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 5000;
        transition: opacity 1.5s ease;
        backdrop-filter: blur(2px);
      }

      #seizureWarning.fadeOut {
        opacity: 0;
        pointer-events: none;
      }

      #enterButton {
        margin-top: 40px;
        padding: 10px 20px;
        font-size: 16px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid white;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        animation: pulse 2s infinite ease-in-out;
      }

      @keyframes pulse {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.08);
        }
      }
      #seizureWarning > div {
        /* This rule is no longer needed; replaced by .warningContent */
      }
      .warningContent {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        max-width: 600px;
        width: 90%;
      }
      /* Prevent selection and tap highlights on long press */
      * {
        -webkit-touch-callout: none; /* iOS Safari long press */
        -webkit-user-select: none;   /* Safari */
        -ms-user-select: none;       /* IE 10+ */
        user-select: none;           /* Standard */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /* Remove gray flash */
      }
    </style>
  </head>

  <div
    id="glitchIndicator"
    style="
      position: fixed;
      top: 100px;
      right: 10px;
      padding: 4px 8px;
      font-family: monospace;
      font-size: 12px;
      background: rgba(255, 0, 255, 0.2);
      color: #ff00ff;
      border: 1px solid #ff00ff;
      border-radius: 4px;
      z-index: 2001;
      display: none;
      pointer-events: none;
      white-space: nowrap;
    "
  >
    ⚡ Glitch Mode On
  </div>
  <body>
    <div id="seizureWarning">
      <div class="warningContent">
        <img 
          src="./assets/image3.png" 
          alt="VisualLife Logo" 
          style="
            width: 240px;
            opacity: 1;
            border-radius: 20px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.2));
            transition: opacity 1s ease-in-out;
          "
        />
        <h1 style="font-size: 2em; color: #ff00ff;">⚡ Seizure Warning ⚡</h1>
        <p style="margin-top: 20px;">
          This visualizer contains intense flashing lights and patterns.<br/>
          Viewer discretion is advised.
        </p>
        <button id="enterButton">Enter</button>
      </div>
    </div>

    <div id="visualizerApp">
      <div
        id="hud"
        style="
          position: fixed;
          top: 0;
          left: 0;
          padding: 10px;
          color: #fff;
          font-family: monospace;
          font-size: 12px;
          z-index: 1000;
        "
      ></div>
      <!-- Mobile Touch Controls (conditionally rendered via JS below) -->

      <!-- Insert HUD buttons dynamically based on screen size and device -->
    <script>

let zoomVelocity = 0;
let targetZoom = 30; // default zoom
let allowAutoWireframeAnimation = true;

let godRaySpreadFactor = 10; // Default spread

// Tighten God Rays: set spread to tight and regenerate temple
function tightenGodRays() {
  godRaySpreadFactor = 3; // Close them in tightly
  regenerateTemple();
  setButtonHighlight("t"); // Optional: highlight the button
}

// --- Toggle random wireframe mode for all meshes/lines/points in the scene ---
let randomWireframeEnabled = false;
function toggleRandomWireframes() {
  // console.log("[RandomOutline] Toggled Random Wireframe:", !randomWireframeEnabled);
  randomWireframeEnabled = !randomWireframeEnabled;
  // allowAutoWireframeAnimation = !randomWireframeEnabled;
  // console.log("[RandomOutline] allowAutoWireframeAnimation:", allowAutoWireframeAnimation);

  scene.traverse((object) => {
    if ((object.isMesh || object.isPoints || object.isLine) && object.material) {
      if (Array.isArray(object.material)) {
        object.material.forEach((mat) => {
          if ('wireframe' in mat) {
            if (randomWireframeEnabled) {
              mat.wireframe = Math.random() > 0.5;
            } else {
              mat.wireframe = false;
            }
          }
        });
      } else if ('wireframe' in object.material) {
        if (randomWireframeEnabled) {
          object.material.wireframe = Math.random() > 0.5;
        } else {
          object.material.wireframe = false;
        }
      }
    }
  });

  sacredGroup.children.forEach((mesh) => {
    if (mesh.material) {
      if (Array.isArray(mesh.material)) {
        mesh.material.forEach((mat) => {
          if ('wireframe' in mat) {
            if (randomWireframeEnabled) {
              mat.wireframe = Math.random() > 0.5;
            } else {
              mat.wireframe = false;
            }
          }
        });
      } else if ('wireframe' in mesh.material) {
        if (randomWireframeEnabled) {
          mesh.material.wireframe = Math.random() > 0.5;
        } else {
          mesh.material.wireframe = false;
        }
      }
      
    }
  });
}
      function detectMobileMode() {
        const isSmallScreen = window.innerWidth <= 1024;
        // console.log(
        //   "Applying mobile mode:",
        //   isSmallScreen,
        //   "| Width:",
        //   window.innerWidth
        // );
        document.body.classList.toggle("mobile", isSmallScreen);
        if (typeof renderHUDButtons === "function") renderHUDButtons();
      }
      window.addEventListener("resize", detectMobileMode);
      window.addEventListener("DOMContentLoaded", () => {
        setTimeout(detectMobileMode, 100); // Delay to ensure correct screen size on load
      });

      function renderHUDButtons() {
        const hud = document.getElementById("hud");
        const controlMap = document.getElementById("controlMap");
        if (!document.getElementById("hud-buttons")) {
          const buttonContainer = document.createElement("div");
          buttonContainer.id = "hud-buttons";
          const controls = [
            { key: "1", label: "View 1" },
            { key: "2", label: "View 2" },
            { key: "3", label: "View 3" },
            { key: "+", label: "Time +" },
            { key: "-", label: "Time -" },
            { key: "0", label: "Time 1x" },
            { key: "g", label: "Glitch" },
            { key: "x", label: "Cycle" },
            { key: "r", label: "Red" },
            { key: "h", label: "Green" },
            { key: "b", label: "Blue" },
            { key: "p", label: "Purple" },
            { key: "y", label: "Yellow" },
            { key: "w", label: "White" },
            { key: "f", label: "Fisheye" },
            { key: "v", label: "Wormhole" },
            { key: "e", label: "Scramble" },
            { key: "k", label: "Push" },
            { key: "l", label: "Pull" },
            { key: "z", label: "Temple" },
            { key: "n", label: "Invert" },
            { key: "c", label: "Contrast" },
            { key: "d", label: "Birghtness" },
            { key: "o", label: "Outline" },
            { key: "q", label: "Randomize Outlines" },
            // { key: "u", label: "Choppy Speed" },
            { key: "arrowLeft", label: "←" },
            { key: "arrowRight", label: "→" },
            { key: "arrowUp", label: "↑" },
            { key: "arrowDown", label: "↓" },
            { key: "s", label: "Spread Rays" },
            { key: "t", label: "Tighten Rays" }
          ];
          const buttonMap = {};
          controls.forEach((control) => {
            const btn = document.createElement("button");
            btn.textContent = control.label;
            btn.style.cssText =
              "margin:4px;background:rgba(255,255,255,0.1);color:white;border:1px solid white;";
            btn.dataset.key = control.key;
            buttonMap[control.key] = btn;
            // Special toggles (that do NOT want rapid-fire)
            if (control.key === "g") {
              btn.addEventListener("click", () => {
                glitchPass.enabled = !glitchPass.enabled;
                const indicator = document.getElementById("glitchIndicator");
                if (glitchPass.enabled) {
                  indicator.style.display = "block";
                  btn.style.backgroundColor = "purple";
                } else {
                  indicator.style.display = "none";
                  btn.style.backgroundColor = "rgba(255,255,255,0.1)";
                }
                setButtonHighlight(control.key);
              });
            } else if (control.key === "f") {
              btn.addEventListener("click", () => {
                fisheyePass.enabled = !fisheyePass.enabled;
                btn.style.backgroundColor = fisheyePass.enabled
                  ? "purple"
                  : "rgba(255,255,255,0.1)";
                setButtonHighlight(control.key);
              });
            } else if (control.key === "v") {
              btn.addEventListener("click", () => {
                wormholePass.enabled = !wormholePass.enabled;
                btn.style.backgroundColor = wormholePass.enabled
                  ? "purple"
                  : "rgba(255,255,255,0.1)";
                setButtonHighlight(control.key);
              });
            }
            // For keys that use KeyboardEvent "keydown" (rapid-fire), including o, q, s, t, and arrows
              if (
                [
                  "+", "-", "0", "1", "2", "3", "x", "r", "h", "b", "p", "y", "w",
                  "e", "k", "l", "z", "c", "d", "arrowLeft", "arrowRight", "arrowUp", "arrowDown",
                  // "u", // Choppy Speed button logic commented out
                  "s", "t", "o", "q"
                ].includes(control.key)
              ) {
              let pressTimer;
              let isPressing = false;

              // For o, q, s, t, use their custom logic on keydown, but also allow rapid fire
              const dispatchKey = () => {
                // Custom logic for o, q, s, t, and arrow keys
                if (control.key === "o") {
                  toggleWireframes();
                  randomWireframeEnabled = false; // deactivate random wireframes if Outline is selected
                  if (btn.style.backgroundColor === "purple") {
                    btn.style.backgroundColor = "rgba(255,255,255,0.1)";
                    wireframeEnabled = false;
                  } else {
                    setButtonHighlight("o");
                    wireframeEnabled = true;
                  }
                } else if (control.key === "q") {
                  toggleRandomWireframes();
                  wireframeEnabled = false; // deactivate solid wireframes if Random is selected
                  setButtonHighlight("q");
                } else if (control.key === "s") {
                  godRaySpreadFactor += 2;
                  if (godRaySpreadFactor > 20) godRaySpreadFactor = 6; // reset loop
                  regenerateTemple();
                  setButtonHighlight("s");
                } else if (control.key === "t") {
                  godRaySpreadFactor = 3;
                  regenerateTemple();
                  setButtonHighlight("t");
                } else if (
                  ["arrowLeft", "arrowRight", "arrowUp", "arrowDown"].includes(control.key)
                ) {
                  // Dispatch KeyboardEvent with correct capitalized Arrow key
                  window.dispatchEvent(
                    new KeyboardEvent("keydown", {
                      key: control.key.replace("arrow", "Arrow"),
                    })
                  );
                  setButtonHighlight(control.key);
                // } else if (control.key === "u") {
                //   choppySpeedEnabled = !choppySpeedEnabled;
                //   setButtonHighlight("u");
                } else {
                  // Default: dispatch keydown event
                  window.dispatchEvent(new KeyboardEvent("keydown", { key: control.key }));
                  // Highlight for view keys and others as needed
                  if (["1", "2", "3"].includes(control.key))
                    activeViewKey = control.key;
                  setButtonHighlight(control.key);
                }
              };

              btn.addEventListener("mousedown", () => {
                isPressing = true;
                dispatchKey();
                pressTimer = setInterval(dispatchKey, 100);
              });

              btn.addEventListener("mouseup", () => {
                clearInterval(pressTimer);
                isPressing = false;
              });

              btn.addEventListener("mouseleave", () => {
                if (isPressing) {
                  clearInterval(pressTimer);
                  isPressing = false;
                }
              });

              // Touch support
              btn.addEventListener("touchstart", (e) => {
                e.preventDefault();
                isPressing = true;
                dispatchKey();
                pressTimer = setInterval(dispatchKey, 100);
              }, { passive: false });

              btn.addEventListener("touchend", () => {
                clearInterval(pressTimer);
                isPressing = false;
              });
            } else if (control.key === "n") {
              btn.addEventListener("click", () => {
                invertPass.enabled = !invertPass.enabled;
                btn.style.backgroundColor = invertPass.enabled
                  ? "purple"
                  : "rgba(255,255,255,0.1)";
              });
            }
            buttonContainer.appendChild(btn);
          });
// --- Toggle wireframe mode for all meshes in the scene ---
let wireframeEnabled = false;
function toggleWireframes() {
  wireframeEnabled = !wireframeEnabled;
  scene.traverse((object) => {
    if (object.isMesh && object.material) {
      if (Array.isArray(object.material)) {
        object.material.forEach((mat) => {
          mat.wireframe = wireframeEnabled;
        });
      } else {
        object.material.wireframe = wireframeEnabled;
      }
    }
  });
}


          let activeViewKey = "1";
          function setButtonHighlight(key) {
            const viewKeys = ["1", "2", "3"];
            const glitchKeys = ["g"];
            const colorKeys = ["r", "h", "b", "p", "y", "w", "x"];
            const fxKeys = ["d", "c", "n"];
            const stickyKeys = ["f", "v"];
            const flashKeys = ["e", "k", "l", "z", "s", "t"];
            const outlineKeys = ["o", "q"];

            Object.entries(buttonMap).forEach(([k, btn]) => {
              if (viewKeys.includes(k)) {
                btn.style.backgroundColor =
                  k === activeViewKey ? "purple" : "rgba(255,255,255,0.1)";
              } else if (glitchKeys.includes(k)) {
                btn.style.backgroundColor = glitchPass.enabled
                  ? "purple"
                  : "rgba(255,255,255,0.1)";
              } else if (colorKeys.includes(k)) {
                if (colorKeys.includes(key)) {
                  btn.style.backgroundColor =
                    k === key ? "purple" : "rgba(255,255,255,0.1)";
                }
              // REMOVE fxKeys "n" highlight logic (handled by toggle button click)
              //} else if (fxKeys.includes(k) && k === key) {
              //  btn.style.backgroundColor = "purple";
              //  setTimeout(() => {
              //    btn.style.backgroundColor = "rgba(255,255,255,0.1)";
              //  }, 500);
              } else if (fxKeys.includes(k) && k === key && k !== "n") {
                btn.style.backgroundColor = "purple";
                setTimeout(() => {
                  btn.style.backgroundColor = "rgba(255,255,255,0.1)";
                }, 500);
              } else if (stickyKeys.includes(k)) {
                if (k === "f") {
                  btn.style.backgroundColor = fisheyePass.enabled
                    ? "purple"
                    : "rgba(255,255,255,0.1)";
                } else if (k === "v") {
                  btn.style.backgroundColor = wormholePass.enabled
                    ? "purple"
                    : "rgba(255,255,255,0.1)";
                }
              } else if (flashKeys.includes(k) && k === key) {
                btn.style.backgroundColor = "purple";
                setTimeout(() => {
                  btn.style.backgroundColor = "rgba(255,255,255,0.1)";
                }, 500);
              } else if (outlineKeys.includes(k)) {
                if (outlineKeys.includes(key)) {
                  btn.style.backgroundColor =
                    k === key ? "purple" : "rgba(255,255,255,0.1)";
                }
              }
            });
          }

          hud.appendChild(buttonContainer);
        }
        // --- Add hide/show Buttons logic for desktop only (after #hud-buttons inserted) ---
        // Wrap hideBtn, showBtn, and showHUD in separate containers to avoid overlapping click areas
        // Only append the hide button if not mobile (width > 1024)
        if (!document.getElementById("hideButtonsBtnContainer") && window.innerWidth > 1024) {
          const hideBtnContainer = document.createElement("div");
          hideBtnContainer.id = "hideButtonsBtnContainer";
          hideBtnContainer.style.position = "fixed";
          hideBtnContainer.style.top = "100px";
          hideBtnContainer.style.left = "10px";
          hideBtnContainer.style.zIndex = "1003";
          hideBtnContainer.style.pointerEvents = "none";
          const hideBtn = document.createElement("button");
          hideBtn.id = "hideButtonsBtn";
          hideBtn.textContent = "Hide Buttons";
          hideBtn.style.cssText =
            "padding:4px 8px;font-size:10px;background:rgba(255,255,255,0.2);color:white;border:1px solid white;border-radius:4px;cursor:pointer;";
          hideBtn.onclick = () => {
            document.getElementById("hud-buttons").style.display = "none";
            hideBtn.style.display = "none";
            hideBtn.style.pointerEvents = "none";
            const showBtn = document.getElementById("showButtonsBtn");
            if (showBtn) {
              showBtn.style.display = "block";
              showBtn.style.pointerEvents = "auto";
              showBtn.style.zIndex = "1003";
            }
          };
          hideBtn.style.display = "none";
          hideBtn.style.pointerEvents = "none";
          hideBtnContainer.appendChild(hideBtn);
          document.body.appendChild(hideBtnContainer);
        }
        // Show Buttons Button (in its own container)
        if (!document.getElementById("showButtonsBtnContainer") && !document.body.classList.contains("mobile")) {
          const showBtnContainer = document.createElement("div");
          showBtnContainer.id = "showButtonsBtnContainer";
          showBtnContainer.style.position = "fixed";
          showBtnContainer.style.top = "100px";
          showBtnContainer.style.left = "10px";
          showBtnContainer.style.zIndex = "1003";
          showBtnContainer.style.pointerEvents = "none";
          const showBtn = document.createElement("button");
          showBtn.id = "showButtonsBtn";
          showBtn.textContent = "Show Buttons";
          showBtn.style.cssText =
            "padding:4px 8px;font-size:10px;background:rgba(255,255,255,0.2);color:white;border:1px solid white;border-radius:4px;cursor:pointer;";
          showBtn.style.display = "none";
          showBtn.style.pointerEvents = "none";
          showBtn.onclick = () => {
            document.getElementById("hud-buttons").style.display = "block";
            showBtn.style.display = "none";
            showBtn.style.pointerEvents = "none";
            const hideBtn = document.getElementById("hideButtonsBtn");
            if (hideBtn) {
              hideBtn.style.display = "block";
              hideBtn.style.pointerEvents = "auto";
              hideBtn.style.zIndex = "1003";
            }
          };
          showBtnContainer.appendChild(showBtn);
          document.body.appendChild(showBtnContainer);
        }
        // Show HUD Button (in its own container)
        // Only append the Show HUD button if not mobile (width > 1024)
        if (window.innerWidth > 1024 && !document.getElementById("showHUDButtonContainer")) {
          const showHUDContainer = document.createElement("div");
          showHUDContainer.id = "showHUDButtonContainer";
          showHUDContainer.style.position = "fixed";
          showHUDContainer.style.top = "140px";
          showHUDContainer.style.left = "10px";
          showHUDContainer.style.zIndex = "1003";
          showHUDContainer.style.pointerEvents = "none";
          const showHUDBtn = document.createElement("button");
          showHUDBtn.id = "showHUDButton";
          showHUDBtn.textContent = "Show HUD";
          showHUDBtn.style.cssText =
            "padding:4px 8px;font-size:10px;background:rgba(255,255,255,0.2);color:white;border:1px solid white;border-radius:4px;cursor:pointer;";
          showHUDBtn.onclick = () => {
            document.getElementById("controlMap").style.display = "block";
            showHUDBtn.style.display = "none";
            showHUDBtn.style.pointerEvents = "none";
          };
          showHUDBtn.style.display = "none";
          showHUDBtn.style.pointerEvents = "none";
          showHUDContainer.appendChild(showHUDBtn);
          document.body.appendChild(showHUDContainer);
          if (document.getElementById("controlMap"))
            document.getElementById("controlMap").style.display = "block";
        }
        // Add image button for toggling hideButtonsBtn on hover and show HUD on click
        if (!document.getElementById("logoToggleBtn")) {
          const imgBtn = document.createElement("img");
          imgBtn.id = "logoToggleBtn";
          imgBtn.src = "./assets/logo.png";
          imgBtn.style.cssText = `
            position:fixed;
            top:100px;
            left:10px;
            width:80px;
            height:80px;
            z-index:1002;
            opacity: 0;
            border-radius: 12px;
            cursor:pointer;
            transition: opacity 0.8s ease, transform 0.2s ease;
          `;
          // --- Responsive adjustments for mobile ---
          if (window.innerWidth <= 1024) {
            imgBtn.style.top = "unset";
            imgBtn.style.bottom = "10px";
            imgBtn.style.left = "10px";
            imgBtn.style.width = "60px";
            imgBtn.style.height = "60px";
            imgBtn.style.opacity = "1";
            imgBtn.style.pointerEvents = "auto"; // ensure it's clickable
            imgBtn.style.zIndex = "1003"; // match other buttons
          }
          let hoverHideTimeout;
          let hoverShowTimeout;
          // Only add hover event listeners on desktop (not mobile)
          if (window.innerWidth > 1024) {
            imgBtn.addEventListener("pointerenter", () => {
              clearTimeout(hoverHideTimeout);
              hoverHideTimeout = setTimeout(() => {
                imgBtn.style.opacity = "0";
                const hudButtons = document.getElementById("hud-buttons");
                const hideBtn = document.getElementById("hideButtonsBtn");
                const showBtn = document.getElementById("showButtonsBtn");
                const showHUD = document.getElementById("showHUDButton");
                // Hide all click areas first
                if (hideBtn) {
                  hideBtn.style.display = "none";
                  hideBtn.style.pointerEvents = "none";
                }
                if (showBtn) {
                  showBtn.style.display = "none";
                  showBtn.style.pointerEvents = "none";
                }
                if (showHUD) {
                  showHUD.style.display = "none";
                  showHUD.style.pointerEvents = "none";
                }
                // Show only the relevant button, and bring it to front, enable pointer events
                if (hudButtons && hudButtons.style.display !== "none") {
                  if (hideBtn) {
                    hideBtn.style.display = "block";
                    hideBtn.style.pointerEvents = "auto";
                    hideBtn.style.zIndex = "1003";
                  }
                } else {
                  if (showBtn) {
                    showBtn.style.display = "block";
                    showBtn.style.pointerEvents = "auto";
                    showBtn.style.zIndex = "1003";
                  }
                }
                const cm = document.getElementById("controlMap");
                if (cm && cm.style.display === "none") {
                  if (showHUD) {
                    showHUD.style.display = "block";
                    showHUD.style.pointerEvents = "auto";
                    showHUD.style.zIndex = "1003";
                  }
                }
                // Enable pointer events on container
                const hideBtnContainer = document.getElementById("hideButtonsBtnContainer");
                const showBtnContainer = document.getElementById("showButtonsBtnContainer");
                const showHUDContainer = document.getElementById("showHUDButtonContainer");
                if (hideBtn && hideBtn.style.display === "block" && hideBtnContainer) {
                  hideBtnContainer.style.pointerEvents = "auto";
                } else if (showBtn && showBtn.style.display === "block" && showBtnContainer) {
                  showBtnContainer.style.pointerEvents = "auto";
                } else if (showHUD && showHUD.style.display === "block" && showHUDContainer) {
                  showHUDContainer.style.pointerEvents = "auto";
                }
                // Move logoToggleBtn below the other buttons
                const logoToggleBtn = document.getElementById("logoToggleBtn");
                if (logoToggleBtn) {
                  logoToggleBtn.style.zIndex = "1001";
                }
              }, 1000);
            });
            imgBtn.addEventListener("pointerleave", () => {
              clearTimeout(hoverShowTimeout);
              hoverShowTimeout = setTimeout(() => {
                // Check if mouse is still over any HUD-related buttons
                const isMouseOverHUD = document.querySelectorAll(':hover');
                const isOverOtherButtons = Array.from(isMouseOverHUD).some(el =>
                  el.id === 'hideButtonsBtn' ||
                  el.id === 'showButtonsBtn' ||
                  el.id === 'showHUDButton'
                );
                // Insert a check to confirm the pointer is still not hovering over logoToggleBtn
                const isStillHoveringLogo = Array.from(isMouseOverHUD).some(el => el.id === 'logoToggleBtn');
                if (!isOverOtherButtons && !isStillHoveringLogo) {
                  imgBtn.style.opacity = "1";
                  // Bring logoToggleBtn back to top layer
                  const logoToggleBtn = document.getElementById("logoToggleBtn");
                  if (logoToggleBtn) {
                    logoToggleBtn.style.zIndex = "1004";
                  }
                }
                const hideBtn = document.getElementById("hideButtonsBtn");
                const showBtn = document.getElementById("showButtonsBtn");
                const showHUD = document.getElementById("showHUDButton");
                // Hide all buttons and disable pointer events
                if (hideBtn) {
                  hideBtn.style.display = "none";
                  hideBtn.style.pointerEvents = "none";
                }
                if (showBtn) {
                  showBtn.style.display = "none";
                  showBtn.style.pointerEvents = "none";
                }
                if (showHUD) {
                  showHUD.style.display = "none";
                  showHUD.style.pointerEvents = "none";
                }
                // Disable pointer events on containers
                const hideBtnContainer = document.getElementById("hideButtonsBtnContainer");
                const showBtnContainer = document.getElementById("showButtonsBtnContainer");
                const showHUDContainer = document.getElementById("showHUDButtonContainer");
                if (hideBtnContainer) hideBtnContainer.style.pointerEvents = "none";
                if (showBtnContainer) showBtnContainer.style.pointerEvents = "none";
                if (showHUDContainer) showHUDContainer.style.pointerEvents = "none";
              }, 1500);
            });
          }
          // MOBILE: Change logoToggleBtn onclick logic and hide HUD button for mobile
          if (window.innerWidth <= 1024) {
            imgBtn.onclick = () => {
              const hudButtons = document.getElementById("hud-buttons");
              const cm = document.getElementById("controlMap");
              if (hudButtons && hudButtons.style.display !== "none") {
                hudButtons.style.display = "none";
                if (cm) cm.style.display = "none";
              } else {
                hudButtons.style.display = "block";
                // HUD stays hidden on mobile
              }
            };
          } else {
            imgBtn.onclick = () => {
              const hudButtons = document.getElementById("hud-buttons");
              const hideBtn = document.getElementById("hideButtonsBtn");
              const showBtn = document.getElementById("showButtonsBtn");
              const cm = document.getElementById("controlMap");
              const showHUD = document.getElementById("showHUDButton");
              if (hudButtons && hudButtons.style.display !== "none") {
                hudButtons.style.display = "none";
                if (hideBtn) {
                  hideBtn.style.display = "none";
                  hideBtn.style.pointerEvents = "none";
                }
                if (showBtn) {
                  showBtn.style.display = "block";
                  showBtn.style.pointerEvents = "auto";
                  showBtn.style.zIndex = "1003";
                }
              } else {
                hudButtons.style.display = "block";
                if (hideBtn) {
                  hideBtn.style.display = "block";
                  hideBtn.style.pointerEvents = "auto";
                  hideBtn.style.zIndex = "1003";
                }
                if (showBtn) {
                  showBtn.style.display = "none";
                  showBtn.style.pointerEvents = "none";
                }
              }
              if (cm && cm.style.display === "none") {
                cm.style.display = "block";
                if (showHUD) {
                  showHUD.style.display = "none";
                  showHUD.style.pointerEvents = "none";
                }
              }
              // Only one click area enabled at a time
              const hideBtnContainer = document.getElementById("hideButtonsBtnContainer");
              const showBtnContainer = document.getElementById("showButtonsBtnContainer");
              if (hideBtn && hideBtn.style.display === "block" && hideBtnContainer) {
                hideBtnContainer.style.pointerEvents = "auto";
                if (showBtnContainer) showBtnContainer.style.pointerEvents = "none";
              } else if (showBtn && showBtn.style.display === "block" && showBtnContainer) {
                showBtnContainer.style.pointerEvents = "auto";
                if (hideBtnContainer) hideBtnContainer.style.pointerEvents = "none";
              }
            };
          }
          document.body.appendChild(imgBtn);
          // Show the button with fade-in after a short delay for effect
          setTimeout(() => {
            // Ensure initial opacity is visible by default on mobile
            if (window.innerWidth <= 1024) {
              imgBtn.style.opacity = "1";
            } else {
              imgBtn.style.opacity = "1";
              imgBtn.dispatchEvent(new Event("pointerenter")); // Simulate hover on load
              // Simulate un-hover after 1 second to mimic brief initial interaction
              setTimeout(() => {
                imgBtn.dispatchEvent(new Event("pointerleave"));
              }, 1000);
            }
          }, 100);
        }
      }

      renderHUDButtons();
      window.addEventListener("resize", renderHUDButtons);
    </script>
    <script>
      // Insert the controlMap panel dynamically after HUD buttons
      (function () {
      function insertControlMap() {
        let controlMap = document.getElementById("controlMap");
        if (!controlMap) {
          controlMap = document.createElement("div");
          controlMap.id = "controlMap";
          controlMap.style.position = "fixed";
          controlMap.style.top = "40px";
          controlMap.style.left = "10px";
          controlMap.style.padding = "10px";
          controlMap.style.background = "rgba(0, 0, 0, 0.5)";
          controlMap.style.color = "#fff";
          controlMap.style.fontFamily = "monospace";
          controlMap.style.fontSize = "11px";
          controlMap.style.zIndex = "500";
          controlMap.style.marginTop = "150px"; // move further below the buttons
          controlMap.style.borderRadius = "5px";
          let html = `
    <strong><div style="text-align: right; margin-bottom: 5px;">
      <button onclick="document.getElementById('controlMap').style.display='none';
      const hoveredEls = document.querySelectorAll(':hover');
      const isHoveringLogo = Array.from(hoveredEls).some(el => el.id === 'logoToggleBtn');
      if (!isHoveringLogo) {
        document.getElementById('showHUDButton').style.display = 'block';
      }" style="background: transparent; color: white; border: none; font-size: 14px; cursor: pointer;">✖</button>
    </div>🖱 Mouse or Touch:</strong><br />
    • Left Drag: Orbit<br />
    • Scroll: Zoom<br />
    • Right Drag: Pan<br /><br />
  `;
  if (window.innerWidth > 1024) {
    html += `
    <strong>⌨️ Keyboard:</strong><br />
    • [1/2/3]: View Modes<br />
    • [Arrow Keys]: Tilt & Rotate<br />
    • [+/-/0]: Speed Up / Slow Down / Reset Speed<br />
    • [-]: Zoom In<br />
    • []]: Zoom Out<br />
    • [F]: Toggle Fisheye Effect<br />
    • [V]: Toggle Wormhole Effect<br />
    • [E]: Scramble Shapes<br />
    • [K]: Push Shapes<br />
    • [L]: Pull Shapes<br />
    • [Z]: Regenerate Temple<br />
    • [C]: Adjust Contrast<br />
    • [D]: Adjust Brightness<br />
    • [N]: Invert Colors<br />
    • [R/H/B/P/Y/W]: Color Palettes<br />
    • [X]: Cycle Random Palette<br />
    • [G]: Hold to Glitch<br />
    • [Q]: Randomize Outlines<br />
    • [O]: Toggle Wireframe Outlines<br />
    • [S]: Spread God Rays<br />
    • [T]: Tighten God Rays<br />
    • [U]: Toggle Choppy Speed<br />
    `;
  }
  controlMap.innerHTML = html;
        }
          // Insert after HUD buttons
          const hud = document.getElementById("hud");
          const buttonContainer = document.getElementById("hud-buttons");
          if (hud && buttonContainer && controlMap.parentNode !== hud) {
            if (controlMap.parentNode)
              controlMap.parentNode.removeChild(controlMap);
            if (buttonContainer.nextSibling) {
              hud.insertBefore(controlMap, buttonContainer.nextSibling);
            } else {
              hud.appendChild(controlMap);
            }
          }
        }
        // Run after renderHUDButtons to ensure buttons exist
        window.addEventListener("DOMContentLoaded", insertControlMap);
        // Also re-run after renderHUDButtons (on resize)
        const origRenderHUDButtons = window.renderHUDButtons;
        window.renderHUDButtons = function () {
          origRenderHUDButtons && origRenderHUDButtons();
          insertControlMap();
        };
        // If renderHUDButtons already ran, run now
        if (document.getElementById("hud-buttons")) insertControlMap();
      })();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/DigitalGlitch.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/GlitchPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/RGBShiftShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/RGBShiftPass.js"></script>
    <script>
      // Seizure warning fade-out logic
      document.addEventListener("DOMContentLoaded", function() {
        var enterBtn = document.getElementById("enterButton");
        if (enterBtn) {
          enterBtn.addEventListener("click", function() {
            const warning = document.getElementById("seizureWarning");
            warning.classList.add("fadeOut");
            setTimeout(() => {
              warning.classList.add("hidden");
            }, 800);
          });
        }
      });
    </script>
    <script>
      // --- Negative Color (Invert) Shader Pass ---
      const invertShader = {
        uniforms: { tDiffuse: { value: null } },
        vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
        fragmentShader: `
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          vec3 negative = vec3(1.0) - color.rgb;
          float brightness = dot(negative, vec3(0.299, 0.587, 0.114));
          negative = mix(negative, vec3(brightness), 0.2); // desaturate slightly
          gl_FragColor = vec4(negative, color.a);
        }
      `,
      };
      const invertPass = new THREE.ShaderPass(invertShader);
      invertPass.enabled = false;
    </script>
    <script>
      // --- Wormhole Distortion Shader Pass ---
      const wormholeShader = {
        uniforms: { tDiffuse: { value: null }, time: { value: 0.0 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
        fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        varying vec2 vUv;
        void main() {
          vec2 p = vUv - 0.5;
          float r = length(p);
          float angle = atan(p.y, p.x) + 0.5 * sin(time + r * 20.0);
          float radius = pow(r, 0.8);
          vec2 uv = 0.5 + vec2(cos(angle), sin(angle)) * radius;
          gl_FragColor = texture2D(tDiffuse, uv);
        }`,
      };
      // --- Meteor Shower System ---
      const meteorGeo = new THREE.BufferGeometry();
      const meteorCount = 100;
      const meteorPos = [];
      const meteorVel = [];
      for (let i = 0; i < meteorCount; i++) {
        meteorPos.push(
          Math.random() * 200 - 100,
          Math.random() * 100 + 100,
          Math.random() * 200 - 100
        );
        meteorVel.push(0, -0.15 - Math.random() * 0.2, 0);
      }
      meteorGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(meteorPos, 3)
      );
      const meteorMat = new THREE.PointsMaterial({
        vertexColors: false,
        size: 1,
        color: new THREE.Color().setHSL(Math.random(), 1, 0.75),
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      setInterval(() => {
        meteorMat.color.setHSL(Math.random(), 1, 0.75);
      }, 300);
      const meteors = new THREE.Points(meteorGeo, meteorMat);
      // ----------------- END Meteor Shower Setup -----------------
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        5,
        2000
      );
      camera.position.z = 30;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);
      // Ensure the canvas fully covers the screen
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.top = "0px";
      renderer.domElement.style.left = "0px";
      renderer.domElement.style.bottom = "0px";
      renderer.domElement.style.right = "0px";
      renderer.domElement.style.width = "100%";
      renderer.domElement.style.height = "100%";

      const composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        2.0, // strength
        0.5, // radius
        0.9 // threshold
      );
      composer.addPass(renderPass);
      composer.addPass(bloomPass);
      const rgbShift = new THREE.ShaderPass(THREE.RGBShiftShader);
      rgbShift.uniforms["amount"].value = 0.0015;
      composer.addPass(rgbShift);
      // Add wormhole pass (after rgbshift)
      const wormholePass = new THREE.ShaderPass(wormholeShader);
      wormholePass.enabled = false;
      composer.addPass(wormholePass);
      // Add meteor shower to scene
      scene.add(meteors);
      // --- Fisheye Shader Pass ---
      const fisheyeShader = {
        uniforms: {
          tDiffuse: { value: null },
          strength: { value: 0.1 },
        },
        vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `,
        fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float strength;
        varying vec2 vUv;

        void main() {
          vec2 uv = vUv * 2.0 - 1.0; // center at (0,0)

          // Create an oval shaped mask
          float x = uv.x * 1.5;  // horizontal stretch
          float y = uv.y * 1.0;  // vertical normal
          float len = sqrt(x*x + y*y);

          // Soften distortion between 0.2 to 1.0 instead of harsh
          float distortion = smoothstep(0.2, 1.0, len);
          float factor = 1.0 + strength * pow(distortion, 2.0) * 1.5;

          vec2 distortedUv = uv / factor + 0.5;
          gl_FragColor = texture2D(tDiffuse, distortedUv);
        }
      `,
      };
      const fisheyePass = new THREE.ShaderPass(fisheyeShader);
      fisheyePass.enabled = false;
      composer.addPass(fisheyePass);
      composer.addPass(invertPass);

      // --- Glitch Pass (subtle, momentary, controlled by glitchMode) ---
      // We define glitchPass here so it's available to animate().
      let glitchPass;

      // --- Retract Shapes effect ---
      function triggerRetract() {
        let startTime = Date.now();
        const duration = 1000;

        function retractStep() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(1, elapsed / duration);

          shapes.forEach((mesh) => {
            if (mesh.userData.initialPosition) {
              mesh.position.lerp(mesh.userData.initialPosition, 0.2);
            }
          });

          if (progress < 1) {
            requestAnimationFrame(retractStep);
          } else {
            shapes.forEach((mesh) => {
              if (mesh.userData.initialPosition) {
                mesh.position.copy(mesh.userData.initialPosition);
              }
              delete mesh.userData.velocity; // Ensure no leftover velocity
            });
          }
        }

        retractStep();
      }

      // --- Time scaling global variables ---
      let timeScale = 0.6;
      let choppySpeedEnabled = false;
      let displayedTimeScale = 0.6;

      // Keyboard event: change color palette with key presses and toggle control map
window.addEventListener("keydown", (e) => {
  switch (e.key) {
    case "ArrowLeft":
      targetYawAngle = Math.max(-Math.PI, targetYawAngle - 0.05);
      break;
    case "ArrowRight":
      targetYawAngle = Math.min(Math.PI, targetYawAngle + 0.05);
      break;
    case "ArrowUp":
      targetTiltAngle = Math.max(-Math.PI/2 + 0.1, targetTiltAngle - 0.05);
      break;
    case "ArrowDown":
      targetTiltAngle = Math.min(Math.PI/2 - 0.1, targetTiltAngle + 0.05);
      break;
    case "=":
    case "+":
      timeScale += 0.05;
      timeScale = Math.min(timeScale, 5.0);
      break;
    case "-":
    case "_":
      timeScale -= 0.05;
      timeScale = Math.max(timeScale, 0.1);
      break;
    case "0":
      timeScale = 1.0;
      break;
    case "[":
      targetZoom -= 1.5;
      targetZoom = Math.max(5, Math.min(150, targetZoom));
      break;
    case "]":
      targetZoom += 1.5;
      targetZoom = Math.max(5, Math.min(150, targetZoom));
      break;
    // (leave the other key cases unchanged below this point)
    case "n":
      invertPass.enabled = !invertPass.enabled;
      if (typeof setButtonHighlight === "function")
        setButtonHighlight("n");
      break;
    case "r": // Red tones
      updatePalette(0.0);
      break;
    case "g":
      glitchPass.enabled = true;
      document.getElementById("glitchIndicator").style.display = "block";
      break;
    case "h":
      updatePalette(0.33);
      break;
    // case "u":
    //   choppySpeedEnabled = !choppySpeedEnabled;
    //   break;
    case "b": // Blue tones
      updatePalette(0.66);
      break;
    case "p": // Purple/pink tones
      updatePalette(0.85);
      break;
    // --- ADD Q KEY FOR RANDOM OUTLINES ---
    case "q":
      toggleRandomWireframes();
      if (typeof setButtonHighlight === "function")
        setButtonHighlight("q");
      break;
    // --- END Q KEY ---
    case "y": // Yellow/orange tones
      updatePalette(0.12);
      break;
    case "c": // Toggle contrast by increasing emissive intensity
      shapes.forEach((mesh) => {
        mesh.material.emissiveIntensity =
          mesh.material.emissiveIntensity === 1 ? 4 : 1;
      });
      break;
    case "d":
      colorLights.forEach((light) => {
        light.intensity = light.intensity > 0.5 ? 0.05 : 3;
      });
      shapes.forEach((mesh) => {
        mesh.material.color.setScalar(
          mesh.material.color.getHex() > 0x222222 ? 0.1 : 1
        );
      });
      if (typeof setButtonHighlight === "function")
        setButtonHighlight("d");
      break;
    case "w":
      shapes.forEach((mesh) => {
        const hsl = {};
        mesh.material.color.getHSL(hsl);
        mesh.material.color.setHSL(hsl.h, 0.05, hsl.l);
        mesh.material.emissive.setHSL(hsl.h, 0.05, hsl.l);
      });
      break;
    case "x": // Randomize everything
      updatePalette(Math.random());
      shapes.forEach((mesh) => {
        mesh.material.emissive.setHSL(Math.random(), 1, 0.5);
        mesh.material.emissiveIntensity = 1 + Math.random() * 4;
      });
      break;
    case "m":
      trailsEnabled = !trailsEnabled;
      break;
    case "1":
      cameraMode = "orbit";
      break;
    case "2":
      cameraMode = "zoom";
      break;
    case "3":
      cameraMode = "top";
      break;
    case "f":
      fisheyePass.enabled = !fisheyePass.enabled;
      break;
    case "e":
      triggerExplosion();
      break;
    case "k":
      triggerRepelExplosion();
      break;
    case "l":
      triggerRetract();
      break;
    case "v":
      wormholePass.enabled = !wormholePass.enabled;
      break;
    // --- Toggle control map panel ---
    case "?":
    case "h":
      const cm = document.getElementById("controlMap");
      cm.style.display = cm.style.display === "none" ? "block" : "none";
      break;
  }
});

      window.addEventListener("keyup", (e) => {
        if (e.key.toLowerCase() === "g") {
          glitchPass.enabled = false;
          document.getElementById("glitchIndicator").style.display = "none";
        }
      });
      function updatePalette(baseHue) {
        colorLights.forEach((light) => {
          light.color.setHSL((baseHue + Math.random() * 0.1) % 1.0, 1, 0.6);
        });
        shapes.forEach((mesh) => {
          const hue = (baseHue + Math.random() * 0.1) % 1.0;
          mesh.material.color.setHSL(hue, 1, 0.5);
          mesh.material.emissive.setHSL(hue, 1, 0.5);
          mesh.material.emissiveIntensity = 2 + Math.random() * 3;
        });
      }

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.006; // Lower value for longer decay
      controls.rotateSpeed = 0.6;     // Lower speed to give finer control
      controls.zoomSpeed = 1.0;
      controls.panSpeed = 0.5;
      // Ensure vertical rotation is enabled and zooming is not caused by vertical drag:
      controls.enableRotate = true;
      controls.enableZoom = true;
      controls.screenSpacePanning = false;
      // Allow unrestricted vertical rotation (polar angle):
      controls.minPolarAngle = -Infinity;
      controls.maxPolarAngle = Infinity;

      // Override OrbitControls update method to safely clamp angles
      const originalUpdate = controls.update.bind(controls);
      controls.update = function () {
        if (this.spherical) {
          this.spherical.theta = (this.spherical.theta + 2 * Math.PI) % (2 * Math.PI);
          this.spherical.phi = (this.spherical.phi + 2 * Math.PI) % (2 * Math.PI);
        }
        originalUpdate();
      };

      // Optionally, allow full azimuth rotation (horizontal orbit):
      controls.minAzimuthAngle = -Infinity;
      controls.maxAzimuthAngle = Infinity;
      // Set the initial target only once and avoid resetting it each frame
      if (!controls.hasSetTarget) {
        controls.target.set(0, 0, 0);
        controls.hasSetTarget = true;
      }
      controls.enablePan = true;
      // Use explicit mouse button mapping to ensure correct behavior
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN,
      };

      let cameraMode = "orbit";
      let manualZoom = 30;
      let tiltAngle = 0;
      let yawAngle = 0;
      let targetYawAngle = 0;
      let targetTiltAngle = 0;
      let theta = 0;

      const colorLights = [];
      for (let i = 0; i < 3; i++) {
        const light = new THREE.PointLight(Math.random() * 0xffffff, 2, 200);
        light.position.set(
          Math.random() * 50 - 25,
          Math.random() * 50 - 25,
          Math.random() * 50 - 25
        );
        scene.add(light);
        colorLights.push(light);
      }

      const randomMat = () =>
        new THREE.MeshStandardMaterial({
          color: Math.random() * 0xffffff,
          roughness: 0.3,
          metalness: 0.6,
          emissive: Math.random() * 0x202020,
        });

      const shapes = [];
      const geoTypes = [
        new THREE.BoxGeometry(5, 5, 5),
        new THREE.SphereGeometry(3, 32, 32),
        new THREE.TorusGeometry(4, 1.5, 16, 100),
        new THREE.IcosahedronGeometry(4),
      ];

      for (let i = 0; i < 50; i++) {
        const geo = geoTypes[Math.floor(Math.random() * geoTypes.length)];
        const mesh = new THREE.Mesh(geo, randomMat());
        mesh.position.set(
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100
        );
        mesh.rotation.set(
          Math.random() * 2,
          Math.random() * 2,
          Math.random() * 2
        );
        scene.add(mesh);
        // Save initial position after adding to scene
        mesh.userData.initialPosition = mesh.position.clone();
        shapes.push(mesh);
      }

      // Sacred Geometry: nested rotating tori + procedural sacred temple generator
      const sacredGroup = new THREE.Group();
      function regenerateTemple() {
        // --- Preserve wireframe states of sacredGroup children by order ---
        let savedWireframeStates = [];
        sacredGroup.children.forEach(child => {
          if (child.material) {
            savedWireframeStates.push({
              isMesh: child.isMesh,
              isPoints: child.isPoints,
              isLine: child.isLine,
              wireframe: (Array.isArray(child.material) ? child.material[0] : child.material).wireframe || false
            });
          }
        });
        // Remove all children
        while (sacredGroup.children.length)
          sacredGroup.remove(sacredGroup.children[0]);

        // --- Dramatic GOD RAYS ---
        const godRayCount = 6 + Math.floor(Math.random() * 4); // 6–9 rays
        for (let i = 0; i < godRayCount; i++) {
          const rayMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
            transparent: true,
            opacity: 0.3 + Math.random() * 0.3,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide,
          });
          const cone = new THREE.Mesh(
            new THREE.ConeGeometry(
              4 + Math.random() * 4,
              40 + Math.random() * 40,
              64,
              1,
              true
            ),
            rayMaterial
          );
          cone.position.set(
            Math.sin(i * 2) * godRaySpreadFactor,
            (Math.random() - 0.5) * 3,
            Math.cos(i * 2) * godRaySpreadFactor
          );
          cone.rotation.x = Math.PI / 2;
          cone.rotation.y = (i / godRayCount) * Math.PI * 2 + Math.random() * (0.2 + godRaySpreadFactor * 0.01);
          sacredGroup.add(cone);
          // --- Restore wireframe state by order ---
          const saved = savedWireframeStates.shift();
          if (saved && (cone.isMesh || cone.isPoints || cone.isLine)) {
            if (Array.isArray(cone.material)) {
              cone.material.forEach((mat) => {
                if ('wireframe' in mat) mat.wireframe = saved.wireframe;
              });
            } else if ('wireframe' in cone.material) {
              cone.material.wireframe = saved.wireframe;
            }
          }
        }

        // --- Dramatic Sacred Tori ---
        const torusCount = 2 + Math.floor(Math.random() * 4); // 2–5 tori
        for (let i = 0; i < torusCount; i++) {
          const torus = new THREE.Mesh(
            new THREE.TorusGeometry(
              10 + i * 2 + Math.random() * 5,
              0.5 + Math.random() * 1.5,
              16,
              100
            ),
            new THREE.MeshStandardMaterial({
              color: new THREE.Color().setHSL(Math.random(), 1, 0.6),
              metalness: 1,
              roughness: 0.1,
              emissive: new THREE.Color().setHSL(Math.random(), 1, 0.3),
            })
          );
          torus.rotation.x = (i * Math.PI) / (2 + Math.random());
          torus.rotation.y = Math.random() * Math.PI * 2;
          torus.rotation.z = Math.random() * Math.PI * 2;
          torus.scale.setScalar(0.8 + Math.random() * 1.5);
          sacredGroup.add(torus);
          // --- Restore wireframe state by order ---
          const saved = savedWireframeStates.shift();
          if (saved && (torus.isMesh || torus.isPoints || torus.isLine)) {
            if (Array.isArray(torus.material)) {
              torus.material.forEach((mat) => {
                if ('wireframe' in mat) mat.wireframe = saved.wireframe;
              });
            } else if ('wireframe' in torus.material) {
              torus.material.wireframe = saved.wireframe;
            }
          }
          // Store original vertices for mutation
          torus.userData.originalVertices =
            torus.geometry.attributes.position.array.slice();
        }

        // --- Dramatic, varied Tetrahedrons ---
        for (let i = 0; i < 10 + Math.floor(Math.random() * 10); i++) {
          const geo = new THREE.TetrahedronGeometry(2 + Math.random() * 2);
          const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(Math.random(), 1, 0.6),
            metalness: 0.6,
            roughness: 0.3,
            emissive: new THREE.Color().setHSL(Math.random(), 1, 0.3),
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.set(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
          );
          mesh.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );
          sacredGroup.add(mesh);
          // --- Restore wireframe state by order ---
          const saved = savedWireframeStates.shift();
          if (saved && (mesh.isMesh || mesh.isPoints || mesh.isLine)) {
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach((mat) => {
                if ('wireframe' in mat) mat.wireframe = saved.wireframe;
              });
            } else if ('wireframe' in mesh.material) {
              mesh.material.wireframe = saved.wireframe;
            }
          }
          // Store original vertices for mutation
          mesh.userData.originalVertices =
            mesh.geometry.attributes.position.array.slice();
        }

        // --- Spiked Sacred Forms ---
        for (let i = 0; i < 4 + Math.floor(Math.random() * 4); i++) {
          const spike = new THREE.Mesh(
            new THREE.ConeGeometry(
              1 + Math.random(),
              10 + Math.random() * 20,
              8
            ),
            new THREE.MeshStandardMaterial({
              color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
              emissive: new THREE.Color().setHSL(Math.random(), 1, 0.3),
              metalness: 0.7,
              roughness: 0.25,
            })
          );
          spike.position.set(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
          );
          spike.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );
          sacredGroup.add(spike);
          // --- Restore wireframe state by order ---
          const saved = savedWireframeStates.shift();
          if (saved && (spike.isMesh || spike.isPoints || spike.isLine)) {
            if (Array.isArray(spike.material)) {
              spike.material.forEach((mat) => {
                if ('wireframe' in mat) mat.wireframe = saved.wireframe;
              });
            } else if ('wireframe' in spike.material) {
              spike.material.wireframe = saved.wireframe;
            }
          }
          spike.userData.originalVertices =
            spike.geometry.attributes.position.array.slice();
        }
      }
      regenerateTemple();
      scene.add(sacredGroup);
      window.addEventListener("keydown", (e) => {
        if (e.key === "z") regenerateTemple();
      });


window.addEventListener("wheel", (e) => {
  if (cameraMode === "zoom") {
    e.preventDefault(); // Prevent default page scroll
    zoomVelocity += e.deltaY * 0.0002; // Adjust scale if needed (positive zooms out)
  }
}, { passive: false });
      const planets = [];
      const orbitLines = new THREE.Group();
      for (let i = 0; i < 5; i++) {
        const radius = 20 + i * 10;
        const angle = Math.random() * Math.PI * 2;

        const planet = new THREE.Mesh(
          new THREE.SphereGeometry(1.5, 16, 16),
          new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
          })
        );
        planet.userData = {
          radius,
          angle,
          speed: 0.001 + Math.random() * 0.002,
        };
        planets.push(planet);
        scene.add(planet);

        const curve = new THREE.EllipseCurve(
          0,
          0,
          radius,
          radius,
          0,
          2 * Math.PI,
          false,
          0
        );
        const points = curve
          .getPoints(64)
          .map((p) => new THREE.Vector3(p.x, 0, p.y));
        const orbitGeo = new THREE.BufferGeometry().setFromPoints(points);
        const orbitLine = new THREE.LineLoop(
          orbitGeo,
          new THREE.LineBasicMaterial({
            color: 0x00ffff,
            opacity: 0.5,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            depthTest: false, // 👈 added
          })
        );
        orbitLines.add(orbitLine);
      }
      scene.add(orbitLines);

// --- Comet Trails for Planets (old bunch-up behavior) ---
const cometTrailLength = 20;
const cometTrailData = planets.map(() => []);
const cometTrailPositions = new Float32Array(
  planets.length * cometTrailLength * 3
);
const cometTrails = new THREE.LineSegments(
  new THREE.BufferGeometry().setAttribute(
    "position",
    new THREE.BufferAttribute(cometTrailPositions, 3)
  ),
  new THREE.LineBasicMaterial({
    color: 0xffccff,
    transparent: true,
    opacity: 0.5,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  })
);
scene.add(cometTrails);
      let trailsEnabled = true;
      // --- Central Spiral Vortex ---
      const vortexGeo = new THREE.RingGeometry(1, 15, 64);
      const vortexMat = new THREE.MeshBasicMaterial({
        color: 0x9933ff,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.25,
      });
      const vortex = new THREE.Mesh(vortexGeo, vortexMat);
      vortex.rotation.x = Math.PI / 2;
      // Make the vortex larger and place it closer to center for enhanced central glow layering
      vortex.scale.set(2.5, 2.5, 2.5);
      vortex.position.y = -1;
      scene.add(vortex);

      // --- Orbiting Glyphs around Sacred Group ---
      const customTexture = new THREE.TextureLoader().load('./assets/spritesacred.png');
      const customMaterial = new THREE.SpriteMaterial({
        map: customTexture,
        color: 0xffffff,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const glyphs = [];
      for (let i = 0; i < 12; i++) {
        const sprite = new THREE.Sprite(customMaterial.clone());
        sprite.scale.set(6, 6, 1);
        scene.add(sprite);
        glyphs.push({ sprite, angle: i * ((Math.PI * 2) / 12), radius: 25 });
      }

      // --- Mirrored Reflective Floor ---
      const floorMat = new THREE.MeshPhongMaterial({
        color: 0x111122,
        shininess: 100,
        specular: 0x888888,
        opacity: 0.4,
        transparent: true,
      });
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -100; // lower the floor
      floor.material.depthWrite = false; // disable depth writing
      scene.add(floor);

      const glassMat = new THREE.MeshPhysicalMaterial({
        color: 0x88ccff,
        metalness: 0.25,
        roughness: 0,
        transmission: 1,
        thickness: 5,
        clearcoat: 1,
        clearcoatRoughness: 0,
        opacity: 1,
        transparent: true,
      });

      const glassSphere = new THREE.Mesh(
        new THREE.SphereGeometry(6, 64, 64),
        glassMat
      );
      glassSphere.position.set(0, 0, -25);
      scene.add(glassSphere);

      // for (let i = 0; i < 8; i++) {
      //   const rune = new THREE.Sprite(runeMat.clone());
      //   rune.scale.set(10, 10, 1);
      //   rune.position.set(
      //     Math.sin(i) * 40,
      //     Math.cos(i) * 40,
      //     Math.sin(i * 2) * 20
      //   );
      //   scene.add(rune);
      // }

      const helixGeo = new THREE.BufferGeometry();
      const helixVerts = [];
      for (let i = 0; i < 200; i++) {
        let t = i / 10;
        helixVerts.push(Math.cos(t) * 8, (i - 100) * 0.2, Math.sin(t) * 8);
      }
      helixGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(helixVerts, 3)
      );
      const helixMat = new THREE.LineBasicMaterial({ color: 0xff99ff });
      const helix = new THREE.Line(helixGeo, helixMat);
      scene.add(helix);

      const starGeo = new THREE.BufferGeometry();
      const starCount = 500;
      const starPos = [];

      for (let i = 0; i < starCount; i++) {
        starPos.push(
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200
        );
      }

      starGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starPos, 3)
      );
      const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
      const stars = new THREE.Points(starGeo, starMat);
      scene.add(stars);

      const glitterGeo = new THREE.BufferGeometry();
      const glitterCount = 1000;
      const glitterPositions = [];
      const glitterColors = [];

      for (let i = 0; i < glitterCount; i++) {
        glitterPositions.push(
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200
        );
        glitterColors.push(Math.random(), Math.random(), Math.random());
      }

      glitterGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(glitterPositions, 3)
      );
      glitterGeo.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(glitterColors, 3)
      );

      const glitterMat = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const glitter = new THREE.Points(glitterGeo, glitterMat);
      scene.add(glitter);

      // Flowing water-like effect: blue transparent particles
      const waterGeo = new THREE.BufferGeometry();
      const waterParticles = [];
      for (let i = 0; i < 800; i++) {
        waterParticles.push(
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300
        );
      }
      waterGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(waterParticles, 3)
      );
      const waterMat = new THREE.PointsMaterial({
        color: 0x3399ff,
        size: 1.5,
        transparent: true,
        opacity: 0.2,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const waterFlow = new THREE.Points(waterGeo, waterMat);
      scene.add(waterFlow);

      // --- Flowing Ribbon Setup ---
      // const curvePath = new THREE.CatmullRomCurve3([
      //   new THREE.Vector3(-20, 0, -20),
      //   new THREE.Vector3(-10, 5, 0),
      //   new THREE.Vector3(0, 0, 20),
      //   new THREE.Vector3(10, -5, 0),
      //   new THREE.Vector3(20, 0, -20),
      // ]);
      // curvePath.closed = true;

      // --- Flowing Ribbon Setup (COMMENTED OUT) ---
      /*
      // Define CatmullRomCurve3 path for flowing ribbon (with increased curvature)
      const ribbonPath = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-60, 15, -60),
        new THREE.Vector3(-30, 30, 0),
        new THREE.Vector3(0, 15, 60),
        new THREE.Vector3(30, 0, 0),
        new THREE.Vector3(60, 15, -60),
      ]);
      ribbonPath.closed = true; // Make it a loop

      // Replace BoxGeometry with PlaneGeometry for a more segment-rich ribbon
      const ribbonGeometry = new THREE.PlaneGeometry(200, 0.1, 800, 1);
      // --- Ribbon Texture Loading ---
      const textureLoader = new THREE.TextureLoader();
      const holographicTexture = textureLoader.load('./assets/imar.png');
      const ribbonMaterial = new THREE.MeshStandardMaterial({
        map: holographicTexture,
        color: new THREE.Color(0xffffff), // neutral white to not tint texture
        metalness: 0.1, // reduce metallic effect to emphasize texture
        roughness: 0.2, // slight roughness for more natural light reflection
        side: THREE.DoubleSide,
        transparent: true,
        envMapIntensity: 1.5,     // Boost reflection intensity

        opacity: .5, // fully visible
        wireframe: true  // Set wireframe to true on creation
      });
      const ribbonMesh = new THREE.Mesh(ribbonGeometry, ribbonMaterial);
      // if (ribbonMesh.material && 'wireframe' in ribbonMesh.material) {
      //   ribbonMesh.material.wireframe = false;
      // }
      scene.add(ribbonMesh);

      // --- Store ribbon mesh globally for animation in next steps ---
      window.ribbon = ribbonMesh;
      // Ensure ribbon stays in wireframe mode
      if (window.ribbon && window.ribbon.material) {
        if (Array.isArray(window.ribbon.material)) {
          window.ribbon.material.forEach((mat) => {
            if ('wireframe' in mat) mat.wireframe = true;
          });
        } else if ('wireframe' in window.ribbon.material) {
          window.ribbon.material.wireframe = true;
        }
      }

      // --- Animate ribbon to follow the path ---
      const positions = ribbonGeometry.attributes.position;
      const pointCount = positions.count;
      const path = ribbonPath;

      function updateRibbon() {
        const time = performance.now() * 0.001;
        // Animate control points over time to create flowing motion
        const animatedPoints = [          
          new THREE.Vector3(-60, 15 + Math.sin(time * 2.5) * 5, -60),
          new THREE.Vector3(-30, 30 + Math.cos(time * 3.0) * 5, 0),
          new THREE.Vector3(0, 15 + Math.sin(time * 3.2) * 5, 60),
          new THREE.Vector3(30, 0 + Math.cos(time * 2.8) * 5, 0),
          new THREE.Vector3(60, 15 + Math.sin(time * 2.4) * 5, -60)
        ];
        const dynamicPath = new THREE.CatmullRomCurve3(animatedPoints);
        dynamicPath.closed = true;

        const positions = ribbonGeometry.attributes.position;
        const pointCount = positions.count;

        for (let i = 0; i < pointCount; i++) {
          const u = i / (pointCount - 1);
          const point = dynamicPath.getPointAt(u);
          const tangent = dynamicPath.getTangentAt(u).normalize();

          // Create normal and binormal
          const normal = new THREE.Vector3(0, 1, 0);
          // --- Use binormal pointing toward average of colorLights ---
          const ribbonToLight = new THREE.Vector3();
          const avgLightPosition = new THREE.Vector3();
          colorLights.forEach(light => avgLightPosition.add(light.position));
          avgLightPosition.divideScalar(colorLights.length);
          ribbonToLight.subVectors(avgLightPosition, ribbonMesh.position).normalize();

          const binormal = new THREE.Vector3().crossVectors(tangent, ribbonToLight).normalize();

          const angle = u * Math.PI * 2 + time * 0.5;
          const twistSin = Math.sin(angle);
          const twistCos = Math.cos(angle);
          const dynamicWidth = 0.3 + 0.05 * Math.sin(u * 10 + time);

          const twistedX = binormal.x * twistCos + normal.x * twistSin;
          const twistedY = binormal.y * twistCos + normal.y * twistSin;
          const twistedZ = binormal.z * twistCos + normal.z * twistSin;

          const twistOffset = new THREE.Vector3(twistedX, twistedY, twistedZ).multiplyScalar((i % 2 === 0 ? -1 : 1) * dynamicWidth);
          const wave = Math.sin(u * 10.0 + time * 2.0) * 2.0;
          positions.setXYZ(i, point.x + twistOffset.x, point.y + twistOffset.y + wave, point.z + twistOffset.z);
        }

        positions.needsUpdate = true;

        // Orbit ribbon around center
        const orbitRadius = 250;
        const angleAroundCenter = time * 0.2;
        ribbonMesh.position.x = Math.sin(angleAroundCenter) * orbitRadius;
        ribbonMesh.position.z = Math.cos(angleAroundCenter) * orbitRadius;
        ribbonMesh.rotation.y = angleAroundCenter + Math.PI / 2;
      }
      */

      // --- Space background with reliable texture and async loading (fully refactored) ---
      const textureLoader = new THREE.TextureLoader();
      const spaceTexture = textureLoader.load(
        "./assets/starfield.png",
        () => {
          console.log("✅ Background texture loaded.");
          spaceTexture.needsUpdate = true;
        },
        undefined,
        (err) => {
          console.warn("❌ Background texture failed to load:", err);
        }
      );

      const skyMaterial = new THREE.MeshBasicMaterial({
        map: spaceTexture,
        side: THREE.BackSide,
        depthWrite: false,
        depthTest: false,
        transparent: false,
      });

      const skySphere = new THREE.Mesh(
        new THREE.SphereGeometry(1000, 64, 64),
        skyMaterial
      );

      skySphere.renderOrder = -1;
      scene.add(skySphere);

      // --- Explosion sound, sparks, and camera shake ---
      let explosionSound;
      try {
        explosionSound = new Audio(
          "https://cdn.jsdelivr.net/gh/matfire/demos/sounds/explosion.mp3"
        );
        explosionSound.addEventListener("error", () => {
          console.warn("Explosion sound could not be loaded or played.");
          explosionSound = { play: () => {} }; // Fallback no-op
        });
      } catch (err) {
        console.warn("Audio playback not supported.");
        explosionSound = { play: () => {} }; // Fallback no-op
      }

      const sparkGeo = new THREE.BufferGeometry();
      const sparkCount = 300;
      const sparkPositions = [];
      const sparkVelocities = [];
      for (let i = 0; i < sparkCount; i++) {
        sparkPositions.push(0, 0, 0);
        sparkVelocities.push(
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 4
        );
      }
      sparkGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(sparkPositions, 3)
      );
      const sparkMat = new THREE.PointsMaterial({
        color: 0xffcc00,
        size: 2,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const sparks = new THREE.Points(sparkGeo, sparkMat);
      scene.add(sparks);
      let sparkActive = false;

      // --- Smoke and glitter burst variables ---
      let smoke,
        smokeGeo,
        smokeVel,
        smokeParticles,
        smokeActive = false;
      let glitterBurst,
        glitterBurstGeo,
        glitterBurstVel,
        glitterBurstParticles,
        glitterBurstActive = false;

      // --- Glitch Pass (subtle, momentary, controlled by glitchMode) ---
      // We define glitchPass here so it's available to animate().
      glitchPass = new THREE.GlitchPass();
      glitchPass.goWild = false;
      glitchPass.enabled = false;
      glitchPass.renderToScreen = false;
      composer.addPass(glitchPass);

      glitchPass.material.uniforms["amount"].value = 0.05;
      glitchPass.material.uniforms["angle"].value = 0.3;
      glitchPass.material.uniforms["seed"].value = 0.4;
      glitchPass.material.uniforms["distortion_x"].value = 1.2;
      glitchPass.material.uniforms["distortion_y"].value = 0.8;
      glitchPass.material.uniforms["col_s"].value = 0.002;

      // --- Time accumulator for time scaling ---
      let timeAccumulator = 0;
      let lastTime = performance.now();

      function animate() {
        // Animate orbiting glyphs
        if (Array.isArray(glyphs)) {
          glyphs.forEach((g) => {
            g.angle += 0.002;
            g.sprite.position.set(
              Math.cos(g.angle) * g.radius,
              8,
              Math.sin(g.angle) * g.radius
            );
          });
        }
        // updateRibbon(); // (COMMENTED OUT)
        // Smooth interpolation for time scale (for smooth time flow)
        if (choppySpeedEnabled) {
          displayedTimeScale += (timeScale - displayedTimeScale) * 0.05;
        } else {
          displayedTimeScale = timeScale;
        }
        // Use displayedTimeScale for all time calculations
        const currentTime = performance.now();
        const delta = (currentTime - lastTime) / 1000; // seconds
        lastTime = currentTime;
        timeAccumulator += delta * displayedTimeScale;
        const now = timeAccumulator * 1000; // keep existing ms logic

        tiltAngle += (targetTiltAngle - tiltAngle) * 0.1;
        yawAngle += (targetYawAngle - yawAngle) * 0.1;
        requestAnimationFrame(animate);

        sacredGroup.rotation.x = tiltAngle;
        sacredGroup.rotation.y = yawAngle;
        // Remove manual sacredGroup rotation override

        sacredGroup.children.forEach((child, index) => {
          if (child.geometry && child.geometry.type === "TorusGeometry") {
            child.rotation.z += (index % 2 === 0 ? 1 : -1) * 0.01 * displayedTimeScale;
          }
        });
        shapes.forEach((shape, i) => {
          shape.rotation.x += (0.002 + i * 0.0001) * displayedTimeScale;
          shape.rotation.y += (0.003 + i * 0.0001) * displayedTimeScale;
        });

        // --- Subtle sacred group drift to prevent stacking at center ---
        sacredGroup.position.x = Math.sin(now * 0.0001) * 0.05;
        sacredGroup.position.z = Math.cos(now * 0.0001) * 0.05;

        if (allowAutoWireframeAnimation) {
          if (Math.floor(now / 5000) % 2 === 0) {
            shapes.forEach((mesh) => (mesh.material.wireframe = true));
          } else {
            shapes.forEach((mesh) => (mesh.material.wireframe = false));
          }
        }
        // else {
        //   console.log("[RandomOutline] Auto wireframe disabled");
        // }
        sacredGroup.rotation.y += 0.006 * displayedTimeScale;
        sacredGroup.rotation.z += 0.003 * displayedTimeScale;
        sacredGroup.position.y = -2;
        // --- Add central distortion orb to reduce whiteout ---
        if (!window.centralDistortionOrb) {
          const orbMat = new THREE.MeshStandardMaterial({
            color: 0xff00ff,
            emissive: 0x550055,
            roughness: 0.3,
            metalness: 0.7,
            transparent: true,
            opacity: 0.8
          });
          const orbGeo = new THREE.SphereGeometry(3, 32, 32);
          const orbMesh = new THREE.Mesh(orbGeo, orbMat);
          orbMesh.position.set(0, -2, 0);
          scene.add(orbMesh);
          window.centralDistortionOrb = orbMesh;
        }
        // --- Sacred geometry mutation: vertex displacement animation ---
        sacredGroup.children.forEach((child) => {
          if (child.geometry && child.geometry.attributes.position) {
            const pos = child.geometry.attributes.position;
            const orig = child.userData.originalVertices;
            if (orig) {
              for (let i = 0; i < pos.count; i++) {
                pos.setX(
                  i,
                  orig[i * 3] + Math.sin(now * 0.001 + i) * 0.2
                );
                pos.setY(
                  i,
                  orig[i * 3 + 1] + Math.cos(now * 0.001 + i) * 0.2
                );
                pos.setZ(
                  i,
                  orig[i * 3 + 2] + Math.sin(now * 0.001 + i) * 0.2
                );
              }
              pos.needsUpdate = true;
            }
          }
        });

        // --- Simple Camera Pulse Animation ---
        // --- Meteor Shower Animation ---
        const mp = meteorGeo.attributes.position.array;
        for (let i = 0; i < meteorCount; i++) {
          mp[i * 3 + 1] += meteorVel[i * 3 + 1] * displayedTimeScale;
          mp[i * 3 + 0] += Math.sin(now * 0.001 + i) * 0.05 * displayedTimeScale;
          if (mp[i * 3 + 1] < -100) {
            mp[i * 3 + 1] = Math.random() * 100 + 100;
            mp[i * 3 + 0] = Math.random() * 200 - 100;
          }
        }
        meteorGeo.attributes.position.needsUpdate = true;

        // // Animate orbiting glyphs
        // glyphs.forEach((g, i) => {
        //   g.angle += 0.002 * displayedTimeScale;

        //   // Pulsing size effect
        //   const pulse = 1 + Math.sin(now * 0.002 + i) * 0.3;
        //   g.sprite.scale.set(5 * pulse, 5 * pulse, 1);

        //   // Orbit position
        //   g.sprite.position.set(
        //     Math.cos(g.angle) * g.radius,
        //     10,
        //     Math.sin(g.angle) * g.radius
        //   );

        //   // Animate opacity (glow effect)
        //   g.sprite.material.opacity = 0.5 + Math.sin(now * 0.003 + i) * 0.3;

        //   // Animate color hue drift
        //   g.sprite.material.color.setHSL(
        //     0.8 + Math.sin(now * 0.001 + i) * 0.05, // hue drift
        //     1,
        //     0.6
        //   );
        // });

        // Animate stationary rune sprites (pinkish-blue outlined ones)
        scene.children.forEach((child) => {
          if (child.isSprite && !glyphs.some(g => g.sprite === child)) {
            // Only affect stationary runes, not orbiting glyphs
            const material = child.material;
            if (material && material.color) {
              const hsl = {};
              material.color.getHSL(hsl);
              const brightness = 0.5 + Math.sin(now * 0.0015 + child.id) * 0.3;
              material.color.setHSL(hsl.h, hsl.s, brightness);
            }
          }
        });

        // Animate pink stationary particles (glitter field)
        if (glitter && glitter.geometry && glitter.geometry.attributes.color) {
          const colors = glitter.geometry.attributes.color;
          for (let i = 0; i < colors.count; i++) {
            const r = colors.getX(i);
            const g = colors.getY(i);
            const b = colors.getZ(i);

            // Detect if it's pinkish (hue ~0.8–0.95)
            const color = new THREE.Color(r, g, b);
            const hsl = {};
            color.getHSL(hsl);

            if (hsl.h > 0.8 && hsl.h < 0.95) {
              // Animate brightness based on time
              const brightness = 0.5 + Math.sin(now * 0.002 + i) * 0.3;
              const newColor = new THREE.Color();
              newColor.setHSL(hsl.h, hsl.s, brightness);

              colors.setXYZ(i, newColor.r, newColor.g, newColor.b);
            }
          }
          colors.needsUpdate = true;
        }

        planets.forEach((planet, i) => {
          planet.userData.angle += planet.userData.speed * timeScale;
          const angle = planet.userData.angle;
          planet.position.set(
            Math.cos(angle) * planet.userData.radius,
            0,
            Math.sin(angle) * planet.userData.radius
          );

          const trail = cometTrailData[i];
          trail.push(planet.position.clone());
          if (trail.length > cometTrailLength) trail.shift();

          for (let j = 0; j < trail.length - 1; j++) {
            const idx = (i * cometTrailLength + j) * 3;
            cometTrailPositions[idx] = trail[j].x;
            cometTrailPositions[idx + 1] = trail[j].y;
            cometTrailPositions[idx + 2] = trail[j].z;
          }
        });
        cometTrails.geometry.attributes.position.needsUpdate = true;

        colorLights.forEach((light) => {
          light.color.setHSL(Math.random(), 1, 0.5);
          light.intensity = 1 + Math.sin(now * 0.001) * 0.5;
        });

        // Animate fisheye intensity
        if (fisheyePass.enabled) {
          fisheyePass.uniforms.strength.value =
            0.4 + Math.sin(now * 0.001) * 0.2;
        }

        // Animate wormhole shader time
        if (wormholePass.enabled) {
          wormholePass.uniforms.time.value += 0.01 * displayedTimeScale;
        }

        // --- Camera mode logic: Enable OrbitControls only in orbit mode ---
        if (cameraMode === "orbit") {
          controls.enabled = true;
          controls.update(); // let OrbitControls handle all movement
        } else {
          controls.enabled = false;
        }

        if (cameraMode === "zoom") {
          zoomVelocity *= 0.93; // slower decay for glide
          manualZoom += (targetZoom - manualZoom) * 0.1; // Smooth interpolation
          manualZoom = Math.max(5, Math.min(150, manualZoom)); // clamp zoom range

          const t = now * 0.0005;
          camera.position.set(
            Math.cos(t) * manualZoom,
            Math.sin(t * 0.7) * manualZoom * 0.4,
            Math.sin(t) * manualZoom
          );
          camera.lookAt(scene.position);
        } else if (cameraMode === "top") {
          // Top-down orbital glide: dynamic X, Y, Z
          const t = now * 0.0003;
          const radius = 60 + Math.sin(t * 2.0) * 20;
          camera.position.set(
            Math.cos(t) * radius,
            40 + Math.sin(t * 1.5) * 20,
            Math.sin(t) * radius
          );
          camera.lookAt(scene.position);
        }

        // --- Spark particles ---
        if (sparkActive) {
          for (let i = 0; i < sparkCount; i++) {
            let x =
              sparkGeo.attributes.position.getX(i) +
              sparkVelocities[i * 3 + 0] * 0.1 * displayedTimeScale;
            let y =
              sparkGeo.attributes.position.getY(i) +
              sparkVelocities[i * 3 + 1] * 0.1 * displayedTimeScale;
            let z =
              sparkGeo.attributes.position.getZ(i) +
              sparkVelocities[i * 3 + 2] * 0.1 * displayedTimeScale;
            sparkGeo.attributes.position.setXYZ(i, x, y, z);
            sparkVelocities[i * 3 + 0] *= 0.94;
            sparkVelocities[i * 3 + 1] *= 0.94;
            sparkVelocities[i * 3 + 2] *= 0.94;
          }
          sparkGeo.attributes.position.needsUpdate = true;
        }

        // --- Smoke animation ---
        if (smokeActive && smokeGeo && smokeVel) {
          const pos = smokeGeo.attributes.position.array;
          for (let i = 0; i < smokeParticles; i++) {
            pos[i * 3 + 0] += smokeVel[i * 3 + 0] * 0.1 * displayedTimeScale;
            pos[i * 3 + 1] += smokeVel[i * 3 + 1] * 0.1 * displayedTimeScale;
            pos[i * 3 + 2] += smokeVel[i * 3 + 2] * 0.1 * displayedTimeScale;
            smokeVel[i * 3 + 0] *= 0.96;
            smokeVel[i * 3 + 1] *= 0.96;
            smokeVel[i * 3 + 2] *= 0.96;
          }
          smokeGeo.attributes.position.needsUpdate = true;
        }

        // --- Glitter burst animation ---
        if (glitterBurstActive && glitterBurstGeo && glitterBurstVel) {
          const pos = glitterBurstGeo.attributes.position.array;
          for (let i = 0; i < glitterBurstParticles; i++) {
            pos[i * 3 + 0] += glitterBurstVel[i * 3 + 0] * 0.13 * displayedTimeScale;
            pos[i * 3 + 1] += glitterBurstVel[i * 3 + 1] * 0.13 * displayedTimeScale;
            pos[i * 3 + 2] += glitterBurstVel[i * 3 + 2] * 0.13 * displayedTimeScale;
            glitterBurstVel[i * 3 + 0] *= 0.93;
            glitterBurstVel[i * 3 + 1] *= 0.93;
            glitterBurstVel[i * 3 + 2] *= 0.93;
          }
          glitterBurstGeo.attributes.position.needsUpdate = true;
        }

        // --- Camera shake REMOVED ---
        // if (Date.now() % 500 < 100 && sparkActive) {
        //   camera.position.x += (Math.random() - 0.5) * 2;
        //   camera.position.y += (Math.random() - 0.5) * 2;
        // }

        controls.update();
        controls.update();
        composer.render();
        // renderer.render(scene, camera);
        glitter.rotation.y += 0.006 * displayedTimeScale;
        glitter.rotation.x += 0.003 * displayedTimeScale;
        // Animate the water flow effect
        waterFlow.rotation.y += 0.001 * displayedTimeScale;
        waterFlow.rotation.x += 0.0005 * displayedTimeScale;

        skySphere.rotation.y += 0.0005 * displayedTimeScale;

        // Animate vortex spiral
        vortex.rotation.z += 0.002 * displayedTimeScale;

        orbitLines.rotation.x = tiltAngle;
        orbitLines.rotation.y = yawAngle;

        const camModeLabel = document.getElementById("camMode");
        if (camModeLabel) camModeLabel.textContent = cameraMode;

        // Animate camera y position unless in orbit mode
        if (cameraMode !== "orbit") {
          camera.position.y = Math.sin(now * 0.001) * 0.5;
        }

        // Optionally: show timeScale somewhere? (Not required.)
      }

      // --- Explosion effect ---
      function triggerExplosion() {
        // glyphs.forEach(g => g.radius += 1.5);
planets.forEach(p => p.userData.radius += 1.5);
        explosionSound.play();
        shapes.forEach((mesh, i) => {
          // Particle burst per shape on explosion
          const particleGeo = new THREE.BufferGeometry();
          const particleCount = 10;
          const particlePos = [];
          const particleVel = [];
          // --- Insert color array for per-particle coloring ---
          const particleColors = [];

          for (let j = 0; j < particleCount; j++) {
            // Add random offset to spawn position (spread out further)
            const offset = new THREE.Vector3(
              (Math.random() - 0.5) * 6,
              (Math.random() - 0.5) * 6,
              (Math.random() - 0.5) * 6
            );
            const spawnPos = mesh.position.clone().add(offset);
            particlePos.push(spawnPos.x, spawnPos.y, spawnPos.z);
            particleVel.push(
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2
            );
          }
          // Insert HSL color generation for each particle
          for (let j = 0; j < particleCount; j++) {
            const hue = (j / particleCount + Math.random() * 0.1) % 1;
            const color = new THREE.Color().setHSL(hue, 1.0, 0.6);
            particleColors.push(color.r, color.g, color.b);
          }

          particleGeo.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(particlePos, 3)
          );
          // Add color attribute to geometry
          particleGeo.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(particleColors, 3)
          );

          const particleMat = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true, // ✅ Vertex colors only — no static color!
          });
          const burst = new THREE.Points(particleGeo, particleMat);
          scene.add(burst);

          let t = 0;
          function animateParticles() {
            const posAttr = particleGeo.attributes.position;
            for (let j = 0; j < particleCount; j++) {
              let i3 = j * 3;
              posAttr.setXYZ(
                j,
                posAttr.getX(j) + particleVel[i3] * 0.1,
                posAttr.getY(j) + particleVel[i3 + 1] * 0.1,
                posAttr.getZ(j) + particleVel[i3 + 2] * 0.1
              );
              particleVel[i3] *= 0.92;
              particleVel[i3 + 1] *= 0.92;
              particleVel[i3 + 2] *= 0.92;
            }
            posAttr.needsUpdate = true;
            if (t++ < 60) requestAnimationFrame(animateParticles);
            else scene.remove(burst);
          }
          animateParticles();

          const dir = new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          )
            .normalize()
            .multiplyScalar(2);
          mesh.userData.velocity = dir;
        });

        // initialize spark velocities and reset positions
        for (let i = 0; i < sparkCount; i++) {
          sparkGeo.attributes.position.setXYZ(i, 0, 0, 0);
        }
        sparkGeo.attributes.position.needsUpdate = true;
        sparkActive = true;
        // --- Cleanup lingering sparks after 3s ---
        setTimeout(() => {
          if (sparks) {
            scene.remove(sparks);
            if (sparks.geometry) sparks.geometry.dispose();
            if (sparks.material) sparks.material.dispose();
            sparks = null;
          }
        }, 3000); // 3 seconds

        // --- Glitter burst ---
        {
          glitterBurstParticles = 300;
          const glitterBurstPos = [];
          glitterBurstVel = [];
          const glitterBurstColors = [];
          for (let i = 0; i < glitterBurstParticles; i++) {
            glitterBurstPos.push(0, 0, 0);
            glitterBurstVel.push(
              (Math.random() - 0.5) * 3.5,
              (Math.random() - 0.5) * 3.5,
              (Math.random() - 0.5) * 3.5
            );
            glitterBurstColors.push(
              Math.random(),
              Math.random(),
              Math.random()
            );
          }
          glitterBurstGeo = new THREE.BufferGeometry();
          glitterBurstGeo.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(glitterBurstPos, 3)
          );
          glitterBurstGeo.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(glitterBurstColors, 3)
          );
          const glitterBurstMat = new THREE.PointsMaterial({
            size: 3.5,
            vertexColors: true,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
          });
          glitterBurst = new THREE.Points(glitterBurstGeo, glitterBurstMat);
          scene.add(glitterBurst);
          glitterBurstActive = true;
          // Remove after 1.2s
          setTimeout(() => {
            if (glitterBurst) {
              scene.remove(glitterBurst);
              glitterBurst = null;
              glitterBurstGeo = null;
              glitterBurstVel = null;
              glitterBurstActive = false;
            }
          }, 1200);
          // --- Cleanup lingering glitterBurst after 3s ---
          setTimeout(() => {
            if (glitterBurst) {
              scene.remove(glitterBurst);
              if (glitterBurst.geometry) glitterBurst.geometry.dispose();
              if (glitterBurst.material) glitterBurst.material.dispose();
              glitterBurst = null;
            }
          }, 3000);
        }

        // --- Smoke burst ---
        {
          smokeGeo = new THREE.BufferGeometry();
          smokeParticles = 200;
          const smokePos = [];
          smokeVel = [];
          for (let i = 0; i < smokeParticles; i++) {
            smokePos.push(0, 0, 0);
            smokeVel.push(
              (Math.random() - 0.5) * 1.2,
              (Math.random() - 0.5) * 1.2,
              (Math.random() - 0.5) * 1.2
            );
          }
          smokeGeo.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(smokePos, 3)
          );
          const smokeMat = new THREE.PointsMaterial({
            color: 0x555555,
            size: 4,
            transparent: true,
            opacity: 0.3,
            blending: THREE.NormalBlending,
            depthWrite: false,
          });
          smoke = new THREE.Points(smokeGeo, smokeMat);
          scene.add(smoke);
          smokeActive = true;
          // Remove after 1.8s
          setTimeout(() => {
            if (smoke) {
              scene.remove(smoke);
              smoke = null;
              smokeGeo = null;
              smokeVel = null;
              smokeActive = false;
            }
          }, 1800);
          // --- Cleanup lingering smoke after 3s ---
          setTimeout(() => {
            if (smoke) {
              scene.remove(smoke);
              if (smoke.geometry) smoke.geometry.dispose();
              if (smoke.material) smoke.material.dispose();
              smoke = null;
            }
          }, 3000);
        }

        let explosionTime = Date.now();
        const explosionDuration = 1500;

        function explodeStep() {
          const elapsed = Date.now() - explosionTime;
          if (elapsed < explosionDuration) {
            shapes.forEach((mesh) => {
              if (mesh.userData.velocity) {
                mesh.position.add(mesh.userData.velocity);
                mesh.userData.velocity.multiplyScalar(0.95);
              }
            });
            requestAnimationFrame(explodeStep);
          } else {
            shapes.forEach((mesh) => {
              delete mesh.userData.velocity;
            });
          }
        }
        explodeStep();
      }

      // --- Repel Explosion effect ---
      function triggerRepelExplosion() {
        shapes.forEach((mesh) => {
          if (!mesh.userData.initialPosition) {
            mesh.userData.initialPosition = mesh.position.clone();
          }
          const dir = mesh.position.clone().normalize().multiplyScalar(10);
          mesh.userData.velocity = dir;

          const particleGeo = new THREE.BufferGeometry();
          const particleCount = 10;
          const particlePos = [];
          const particleVel = [];
          const particleColors = [];

          for (let j = 0; j < particleCount; j++) {
            // Add random offset to spawn position (spread out further)
            const offset = new THREE.Vector3(
              (Math.random() - 0.5) * 6,
              (Math.random() - 0.5) * 6,
              (Math.random() - 0.5) * 6
            );
            const spawnPos = mesh.position.clone().add(offset);
            particlePos.push(spawnPos.x, spawnPos.y, spawnPos.z);
            particleVel.push(
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2,
              (Math.random() - 0.5) * 2
            );
            const hue = (j / particleCount + Math.random() * 0.1) % 1;
            const color = new THREE.Color().setHSL(hue, 1.0, 0.6);
            particleColors.push(color.r, color.g, color.b);
          }

          particleGeo.setAttribute(
            "position",
            new THREE.Float32BufferAttribute(particlePos, 3)
          );
          particleGeo.setAttribute(
            "color",
            new THREE.Float32BufferAttribute(particleColors, 3)
          );

          const particleMat = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true
          });

          const burst = new THREE.Points(particleGeo, particleMat);
          scene.add(burst);

          let t = 0;
          function animateParticles() {
            const posAttr = particleGeo.attributes.position;
            for (let j = 0; j < particleCount; j++) {
              const i3 = j * 3;
              posAttr.setXYZ(
                j,
                posAttr.getX(j) + particleVel[i3] * 0.1,
                posAttr.getY(j) + particleVel[i3 + 1] * 0.1,
                posAttr.getZ(j) + particleVel[i3 + 2] * 0.1
              );
              particleVel[i3] *= 0.92;
              particleVel[i3 + 1] *= 0.92;
              particleVel[i3 + 2] *= 0.92;
            }
            posAttr.needsUpdate = true;
            if (t++ < 60) requestAnimationFrame(animateParticles);
            else scene.remove(burst);
          }
          animateParticles();
        });

        let startTime = Date.now();
        const duration = 2000;

        // Repel movement: ramp up (ease-in) outward movement
        function repelStep() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(1, elapsed / duration);

          shapes.forEach((mesh) => {
            if (mesh.userData.velocity) {
              // Start slow, accelerate outward
              const ramp = Math.pow(progress, 2); // ease-in
              mesh.position.add(
                mesh.userData.velocity.clone().multiplyScalar(0.08 * ramp)
              );
            }
          });

          if (progress < 1) {
            requestAnimationFrame(repelStep);
          } else {
            shapes.forEach((mesh) => {
              delete mesh.userData.velocity;
            });
          }
        }

        repelStep();
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });
      // --- Zoom Fractal-Style Shader Distortion Toggle (wormholePass) ---
      // See wormholePass above, toggle with 'v'

      // --- REMOVE on-screen glitch toggle button event logic ---
      // (Removed per instructions)
    </script>
    </div> <!-- end #visualizerApp -->
  </body>
</html>
i

        // --- Cleanup lingering sparks after 3s ---
        setTimeout(() => {
          if (sparks) {
            scene.remove(sparks);
            if (sparks.geometry) sparks.geometry.dispose();
            if (sparks.material) sparks.material.dispose();
            sparks = null;
          }
        }, 3000); // 3 seconds

        // --- Cleanup lingering glitterBurst after 3s ---
        setTimeout(() => {
          if (glitterBurst) {
            scene.remove(glitterBurst);
            if (glitterBurst.geometry) glitterBurst.geometry.dispose();
            if (glitterBurst.material) glitterBurst.material.dispose();
            glitterBurst = null;
          }
        }, 3000);

        // --- Cleanup lingering smoke after 3s ---
        setTimeout(() => {
          if (smoke) {
            scene.remove(smoke);
            if (smoke.geometry) smoke.geometry.dispose();
            if (smoke.material) smoke.material.dispose();
            smoke = null;
          }
        }, 3000);
    case "t":
      tightenGodRays();
      break;
// Ensure dynamic resizing of renderer and composer
window.addEventListener("resize", () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});ti